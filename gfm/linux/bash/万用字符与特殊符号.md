### 万用字符与特殊符号

嘿嘿！在 bash 里头还支持一些万用字符喔 (wild card) ！多了这些万用字符， 我们利用 bash 处理数据就更方便了！底下我们列出一些常用的万用字符喔：

符号 | 内容
 --- | ---
 \* | 万用字符，代表 0 个或多个字符（或数字）
?  | 万用字符，代表『一定有』一个字母
\#  | 批注，这个最常被使用在 script 当中，视为说明！
\\  | 跳脱符号，将『特殊字符或万用字符』还原成一般字符
 |   分隔两个管线命令的界定；
;  | 连续性命令的界定（注意！与管线命令并不相同）
~  | 使用者的家目录
$  | 亦即是变量之前需要加的变量取代值
&  | 将指令变成背景下工作
!  | 逻辑运算意义上的『非』 not 的意思！
/  | 路径分隔的符号
\>, \>\> | 输出导向，分别是『取代』与『累加』
'  | 单引号，不具有变量置换的功能
"  | 具有变量置换的功能！
\` \`|   两个『 \` 』中间为可以先执行的指令！
( ) | 在中间为子 shell 的起始与结束
[ ] | 在中间为字符的组合
{ } | 在中间为命令区块的组合！

组合按键 | 执行结果
 --- | ---
 Ctrl + C | 终止目前的命令
Ctrl + D  | 输入结束（EOF），例如邮件结束的时候；
Ctrl + M  | 就是 Enter 啦！
Ctrl + S  | 暂停屏幕的输出
Ctrl + Q  | 恢复屏幕的输出
Ctrl + U  | 在提示字符下，将整列命令删除
Ctrl + Z  | 『暂停』目前的命令


在上面的『按键组合』当中，有没有发现跟上个小节很相似的内容啊！？ 呵呵～没错啦！那些组合键都可以在 stty 当中来进行不同的设定的！好玩吧！ 至于上面的万用字符当中，最常用的就属 \*, ?, [] 及 \`了！我们提几个简单的例子：  

```
[root@linux ~]# ls test* <==那个 * 代表后面不论接几个字符都予以接受
[root@linux ~]# ls test? <==那个 ? 代表后面『一定』要接『一个』字符
[root@linux ~]# ls test??? <==那个 ??? 代表『一定要接三个』字符！
[root@linux ~]# cp test[1-5] /tmp
# 将 test1, test2, test3, test4, test5 若存在的话，就拷贝到 /tmp
[root@linux ~]# cp test[!1-5] /tmp
# 只要不是 test1, test2, test3, test4, test5 之外的其它 test? ，
# 若存在的话，就拷贝到 /tmp
[root@linux ~]# cd /lib/modules/`uname -r`/kernel/drivers
# 被 ` ` 括起来的内容『会先执行』
```

上面几个例子相当的有趣！尤其是最后面两个！需要注意的是， [1-5] 里面『代表只有一个字符』但是范围可以由 1-5 ，这样来说的话，那么我们如果允许『只要档名里面含有至少一个大写字符』时，就可以将档案 copy 出来的话，可以这样做：  
`cp *[A-Z]* /tmp  `  
很有趣吧？！也就是说『 [ ] 谨代表一个字符，而这个字符的定义可以是范围(-)， 可以是指定项目，也可以是两者并存。 』举例来说，我想要找出在 /etc/ 底下所有含有数字的档案， 可以这样：  
`ls -lda /etc/*[0-9]*`  
但如果我只想要找出含有 3 及 5 的档名的档案呢？就会是这样：  
`ls -lda /etc/*[35]*`  
如果是『不想要』某些范围或者是单字呢？就使用 [!] 即可！例如不想要有小写字符为开头的档案：  
`ls -lda /etc/[!a-z]*`  
很好玩吧！至于那个 \` 是啥？在一串指令当中， `command` 内的指令会先被执行， 执行完的讯息再回传到外部指令来处理！也就是说：
	1. 系统先执行 uname -r 找出输出的结果；
	2. 将结果累加在目录上面，来执行 cd 的功能！
很棒吧！！另外，这个 quot (\`) 的功能，也可以利用 $() 来取代喔！例如：  
`cd /lib/modules/$(uname -r)/kernel`  
这些基本的功能需要特别来了解一下才行呦！至于更多的使用方式， 我们会在后续的正规表示法当中在详谈的！
