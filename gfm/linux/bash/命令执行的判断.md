## 命令执行的判断依据： ; , &&, ||

在某些时候，我们希望可以一次执行多个指令，例如关机时，希望我可以先执行两次 sync ，然后才shutdown 计算机，那么可以怎么作呢？这样做呀：  
`[root@linux ~]# sync; sync; shutdown -h now`  
在指令与指令中间利用分号 (;) 来隔开，这样一来，分号前的指令执行完后， 就会立刻接着执行后面的指令了。这真是方便啊～再来，换个角度来想， 万一我想要在某个目录底下建立一个档案，也就是说，如果该目录存在的话， 那我才建立这个档案，如果不存在，那就算了  
～目录是否存在可以使用一些 bash 提供的判断式功能， 但这里假设我不晓得那个指令，但我知道我可以使用 ls 来判断是否有该目录的存在，也就是说，我可以利用 ls directoryname 判断是否存在，然后以 touch 建立一个档案， 这两个指令有相关性，那该如何写呢？呵呵！可以利用 && 来作喔！  
`[root@linux ~]# ls /tmp && touch /tmp/testingagin`  
是否记得我们在变量的章节里面谈过这个奇怪的变数『 $? 』呢？ 如果指令执行结果没有错误讯息，那就会回传 $?=0 ，如果有错误， 那回传值就不会是 0 啊！经由这样的判断，我们也可以利用 && 来决定， 当前面的指令执行结果为正确 (例如：仅有 standard output 时)，就可以接着执行后续的指令， 否则就予以略过！因此，当 ls /tmp 没有问题，那么就会接着执行 touch /tmp/testingagin 了！  
万一是这样：  
`[root@linux ~]# ls /vbird && touch /vbird/test`  
因为我的系统里面根本就不可能存在 /vbird 这个目录呢！所以，执行 ls /vbird 就会回传错误， 那么后续的 touch /vbird/test 自然就不会动作啰！了解吗？

再换个角度来想，如果我想要当某个档案不存在时，就去建立那个档案， 否则就略过呢？很简单啊～可以这样做：  
`[root@linux ~]# ls /tmp/vbirding || touch /tmp/vbirding`  
那个 || 刚好完全跟 && 相反，当前一个指令有错误时，在 || 后面的指令才会被执行！ (要注意，那个 |是两个 | ，而 | 按键则是反斜线 \\ 同一个按键， 因此，按下 [Shift] 加上 [\\] 就会出现那个 | 啰！)  
因此，简单的来说，当 ls /tmp/vbirding 发生错误时，才会使用 touch /tmp/vbirding 去建立这个档案的意思。 是否很有趣啊？这个 || 及 && 对于系统管理员在管理某些档案权限、存在等问题时， 可是很有用的东西喔！好了，现在我们来玩比较难一点的，看看底下的例题：  

**例题：以 ls 测试 /tmp/vbirding 是否存在，若存在则显示 "exist" ，若不存在，则显示 "notexist"！**  
答：这又牵涉到逻辑判断的问题，如果存在就显示某个数据，若不存在就显示其它数据，那我可以这样做：  
`ls /tmp/vbirding && echo "exist" || echo "not exist"`  
意思是说，当 `ls /tmp/vbirding` 执行后，若正确，就执行 `echo "exist"` ，若有问题，就执行 `echo "not exist" ！`那如果我写成：
`ls /tmp/vbirding || echo "not exist" && echo "exist"`对不对啊？这其实是有问题的，为什么呢？因为指令是一个一个往下执行，因此，在上面的例子当中，如果 /tmp/vbirding 不存在时，他会：  
	1. 若 ls /tmp/vbirding 不存在，因此回传一个非为 0 的数值；
	2. 接下来经过 || 的判断，发现前一个指令回传非为 0 的数值，因此，程序开始执行 echo "not exist" ，而 echo "not exist" 程序肯定可以执行成功，因此会回传一个 0 值给后面的指令；
	3. 经过 && 的判断，咦！是 0 啊！所以就开始执行 echo "exist" 。


所以啊，嘿嘿！第二个例子里面竟然会同时出现 not exist 与 exist 呢！真神奇～
