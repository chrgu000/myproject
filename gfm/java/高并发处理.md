### 如何处理并发和同步
>&emsp;&emsp;今天讲的如何处理并发和同同步问题主要是通过锁机制。  
> &ensp;&ensp;&ensp;&ensp;我们需要明白，锁机制有两个层面。  
> 　　一种是代码层次上的，如java中的同步锁，典型的就是同步关键字synchronized，这里我不在做过多的讲解，感兴趣的可以参考:http://www.cnblogs.com/xiohao/p/4151408.html  
> 　　另外一种是数据库层次上的，比较典型的就是悲观锁和乐观锁。这里我们重点讲解的就是悲观锁（传统的物理锁）和乐观锁。

##### 悲观锁(Pessimistic Locking)
>  悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自 外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。  
> 悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能 真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系 统不会修改数据）。
> 一个典型的倚赖数据库的悲观锁调用： `select * from account where name=”Erica” for update`

##### 乐观锁(Optimistic Locking)
>  相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依 靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库 性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。  
> 如一个金融系统，当某个操作员读取用户的数据，并在读出的用户数据的基础上进 行修改时（如更改用户帐户余额），如果采用悲观锁机制，也就意味着整个操作过 程中（从操作员读出数据、开始修改直至提交修改结果的全过程，甚至还包括操作 员中途去煮咖啡的时间），数据库记录始终处于加锁状态，可以想见，如果面对几 百上千个并发，这样的情况将导致怎样的后果。  
> 乐观锁机制在一定程度上解决了这个问题。
>  乐观锁，大多是基于数据版本   Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来 实现。 读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。  
> 此时，将提 交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据 版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据

***

### 常见的提高高并发下访问的效率的手段

##### 首先要了解高并发的的瓶颈在哪里？
1. 可能是服务器网络带宽不够
2. 可能web线程连接数不够
3. 可能数据库连接查询上不去。

##### 根据不同的情况，解决思路也不同。
1. 像第一种情况可以增加网络带宽，DNS域名解析分发多台服务器。
2. 负载均衡，前置代理服务器nginx、apache等等
3. 数据库查询优化，读写分离，分表等等

###### 最后复制一些在高并发下面需要常常需要处理的内容
- 尽量使用缓存，包括用户缓存，信息缓存等，多花点内存来做缓存，可以大量减少与数据库的交互，提高性能。
- 用jprofiler等工具找出性能瓶颈，减少额外的开销。
- 优化数据库查询语句，减少直接使用hibernate等工具的直接生成语句（仅耗时较长的查询做优化）。
- 优化数据库结构，多做索引，提高查询效率。
- 统计的功能尽量做缓存，或按每天一统计或定时统计相关报表，避免需要时进行统计的功能。
- 能使用静态页面的地方尽量使用，减少容器的解析（尽量将动态内容生成静态html来显示）。
- 解决以上问题后，使用服务器集群来解决单台的瓶颈问题。

---

### java高并发，如何解决，什么方式解决
> 一种是使用缓存、另一种是使用生成静态页面；还有就是从最基础的地方优化我们写代码减少不必要的资源浪费：
	1. 不要频繁的new对象,对于在整个应用中只需要存在一个实例的类使用单例模式.对于String的连接操作,使用StringBuffer或者StringBuilder.对于utility类型的类通过静态方法来访问。
	2. 避免使用错误的方式,如Exception可以控制方法推出,但是Exception要保留stacktrace消耗性能,除非必要不要使用 instanceof做条件判断,尽量使用比的条件判断方式.使用JAVA中效率高的类,比如ArrayList比Vector性能好。

**解决思路是：**

1. 采用分布式应用设计
2. 分布式缓存数据库
3. 代码优化
